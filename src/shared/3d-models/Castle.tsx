/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: lepkarepka (https://sketchfab.com/lepkarepka14)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/fantastic-castle-08a018e4e7b3486dbec7b0341be3aeb4
Title: Fantastic castle
*/

import {useEffect, useRef} from 'react'
import {useGLTF} from '@react-three/drei'
// @ts-ignore
import castleScene from "../../assets/fantastic_castle.glb";
import {GLTF} from "three-stdlib";
import {a} from "@react-spring/three"
import * as THREE from "three";
import {useFrame, useThree} from "@react-three/fiber";

type GLTFResult = GLTF & {
    nodes: {
        ['��������������001_����������������003_0']: THREE.Mesh
        ['������008_����������������002_0']: THREE.Mesh
        ['������010_����������������001_0']: THREE.Mesh
        ['������011_����������������_0']: THREE.Mesh
        ['������������������_����������������004_0']: THREE.Mesh
    }
    materials: {
        ['.003']: THREE.MeshStandardMaterial
        ['.002']: THREE.MeshStandardMaterial
        ['.001']: THREE.MeshStandardMaterial
        material: THREE.MeshStandardMaterial
        ['.004']: THREE.MeshStandardMaterial
    }
}
type Props = {
    isRotating: boolean
    setIsRotating: (isRotating: boolean) => void
    position: any
    scale: any
    rotation: any
    setCurrentStage: (stage: number) => void
}

export function Castle({isRotating, setIsRotating, setCurrentStage, ...props}: Props) {
    const castleRef = useRef<THREE.Group>(null)
    const {gl, viewport} = useThree()
    const {nodes, materials} = useGLTF(castleScene) as GLTFResult

    const lastX = useRef(0)
    const rotationSpeed = useRef(0)
    const dampingFactor = 0.95

    const handlePointerDown = (e: PointerEvent | TouchEvent) => {
        e.preventDefault()
        setIsRotating(true)
        const clientX = 'touches' in e ? e.touches[0].clientX : (e as PointerEvent).clientX
        lastX.current = clientX
    }

    const handlePointerUp = () => {
        setIsRotating(false)
    }

    const handlePointerMove = (e: PointerEvent | TouchEvent) => {
        if (!isRotating || !castleRef.current) return
        const clientX = 'touches' in e ? e.touches[0].clientX : (e as PointerEvent).clientX
        const delta = (clientX - lastX.current) / viewport.width
        castleRef.current.rotation.y += delta * 0.01 * Math.PI
        lastX.current = clientX
        rotationSpeed.current = delta * 0.01 * Math.PI
    }

    const handleKeyDown = (e: KeyboardEvent) => {
        if (!castleRef.current) return
        if (e.key === 'ArrowLeft') {
            setIsRotating(true)
            castleRef.current.rotation.y += 0.01 * Math.PI
        } else if (e.key === 'ArrowRight') {
            setIsRotating(true)
            castleRef.current.rotation.y -= 0.01 * Math.PI
        }
    }

    const handleKeyUp = (e: KeyboardEvent) => {
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            setIsRotating(false)
        }
    }

    useEffect(() => {
        const canvas = gl.domElement
        canvas.addEventListener('pointerdown', handlePointerDown)
        canvas.addEventListener('pointerup', handlePointerUp)
        canvas.addEventListener('pointermove', handlePointerMove)
        window.addEventListener('keydown', handleKeyDown)
        window.addEventListener('keyup', handleKeyUp)

        return () => {
            canvas.removeEventListener('pointerdown', handlePointerDown)
            canvas.removeEventListener('pointerup', handlePointerUp)
            canvas.removeEventListener('pointermove', handlePointerMove)
            window.removeEventListener('keydown', handleKeyDown)
            window.removeEventListener('keyup', handleKeyUp)
        }
    }, [gl, isRotating])

    useFrame(() => {
        if (!castleRef.current) return

        if (!isRotating) {
            rotationSpeed.current *= dampingFactor
            if (Math.abs(rotationSpeed.current) < 0.001) {
                rotationSpeed.current = 0
            }
            castleRef.current.rotation.y += rotationSpeed.current
        }

        // Определяем текущий этап на основе угла поворота
        const rotation = castleRef.current.rotation.y;
        const normalizedRotation = ((rotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);

        // Разделяем полный оборот (2π) на 4 этапа
        const stage = Math.floor(normalizedRotation / (Math.PI / 2)) + 1;
        setCurrentStage(stage > 4 ? 1 : stage);
    })

    return (
        <a.group {...props} ref={castleRef}>
            <group rotation={[-Math.PI / 2, 0, 0]} scale={0.01} position={props.position || [0, -2, 0]}>
                <group rotation={[Math.PI / 2, 0, 0]}>
                    <mesh
                        castShadow
                        receiveShadow
                        geometry={nodes['��������������001_����������������003_0'].geometry}
                        material={materials['.003']}
                        position={[7366.46, 2628.348, 6702.574]}
                        rotation={[-Math.PI / 2, 0, 0]}
                        scale={100}
                    />
                    <mesh
                        castShadow
                        receiveShadow
                        geometry={nodes['������008_����������������002_0'].geometry}
                        material={materials['.002']}
                        position={[-8870.991, 1117.951, 8887.213]}
                        rotation={[-Math.PI / 2, 0, -0.917]}
                        scale={100}
                    />
                    <mesh
                        castShadow
                        receiveShadow
                        geometry={nodes['������010_����������������001_0'].geometry}
                        material={materials['.001']}
                        position={[-1561.231, 1156.779, 8464.42]}
                        rotation={[-Math.PI / 2, 0, 0]}
                        scale={100}
                    />
                    <mesh
                        castShadow
                        receiveShadow
                        geometry={nodes['������011_����������������_0'].geometry}
                        material={materials.material}
                        position={[-1739.304, 1213.496, 5251.469]}
                        rotation={[-Math.PI / 2, 0, 0]}
                        scale={100}
                    />
                    <mesh
                        castShadow
                        receiveShadow
                        geometry={nodes['������������������_����������������004_0'].geometry}
                        material={materials['.004']}
                        position={[-1609.998, -270.173, 5555.747]}
                        rotation={[-Math.PI / 2, 0, 0]}
                        scale={100}
                    />
                </group>
            </group>
        </a.group>
    )
}
